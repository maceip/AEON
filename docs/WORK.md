1) SUPPORTING-VIEW PANE:
  a) jedi doors slide from middle open and closed -- door material itself is a 3d mesh thats semi-acrylic and green wire mesh and black smoke fill + blur
  b) this pane is wear the apps render when clicked from the APP-RAIL PANE (below). when an app switches the whole window should routate like a hidden door behind a fireplace. so far we have notepad, git worktree, copy-paste hub (activates when you hit ctrl+c but if no mouse over it goes back to app, ENV config as hearthstone style gem select.
  C) Holographic this one's unique as it will have its own pan A where we will use  One of those old school computers one of those thinking machines with the red lights on the sides a little bit little evil looking or Rehoboth from Westworld SDF in the R3F folder when focused this has a chat box and some settings for interacting with the model when on another the bottom 1 will be taken up by a band that the L kind of dances around or moves around or is just there so there's some interactivity 
2) APP-RAIL PANE
   This sort of looks like a train track on its side: [===] <- accept the Horizontal rails are near the and 3D rendered app shapes glide on the rails with a blue glow a white electric a notepad A Github app and what I mean by that is render chunky pillow sized icon of a notepad of the Github octoc of Claude code splat logo of Gemini's star logo When clicked these activate the supporting pane above 
3) TERMINAL:
   This is the starting point for our customers and users this window needs to high perform resizable drag minimizable dock change the pop out button so it actually pops out a terminal the same size as it This should feel exactly like someone's regular terminal in terms of configurability in terms of keyboard interaction it should already have drag and drop decompress for zip and because it's got SIXCL support it can do inline image display  
   He's gotten feedback that we need to bring the tab view back not everybody's a big fan of having a bunch of windows all over the place and so we need to prove that we can do the window animation in React I'm not sure if we can where you drag the title bar up near the top of the window and it morphs it into a tab Chrome tries to do this This is really hard to get right This also means tab reordering needs to be buttery smooth and look very very good This has challenges with mobile has to work on mobile Mobile obviously can't even do pop out so mobile will just be pop into a tab and the tab bar has to be able to be dragged to the left like those weird people who are big fans of that browser forget what it's called with the vertical tabs Has to look very much like that while keeping the Eon Flux and Blade Runner esthetic add event onto the bottom middle of the tab bar when it's vertical and only show the tab bar if somebody drags the main title bar U and spray paint some white Japanese letters about size 4 font face on the top right 
   The instruction counter needs to work I think we've been having problems with suspend and resume and so maybe if it's easier we just do suspend is global like you don't get to move other windows around when you're suspending in the tab on the browser you're in if you open up another tab that should be isolated the first tab you're in unless you have a setting turned on that enables multi tab orchestration then that setting should be right near the setting that encourages and configures your local file system merging with the browser's OPF 
   But everything up above is contingent on us actually being able to emulate applications people are obsessed with today namely Claude Code Google Gemini CLI and Cursor CLI and code We spend a bunch of time on Claude because we thought it would be the hardest one to do and we're not even sure yet if we can make it in a way that's performant and we didn't want to rice it up and individually try to make them go fast we wanna make this general purpose so people don't write anything in there eventually 
   So what is the goal of this thing why are we doing this The idea is security sandboxing multi flexing We want to make this a tool that helps you use multiple terminals at the same time quickly And the goal is for developers designers people building things so that's like The point is you would use to build software it's almost like a modern IDE for young people and so it has to be fluid copy paste it has to have really good support for the tool kits people want to use like Python TypeScript node J to some Kotlin and Swift and one of the things that like might be easier than we think that it provides a lot of value is just basic roject management stuff someone comes in here and they want to build a demo the supporting view should automatically switch to something like the Notepad view like the Can band view that's keeping track what you've done so far with that idea in that app to the extent we can build more features like that we're going to focus there I eat very strong get support or it's worth looking at that one guys repo beans on Github it's kind of like a get you could host locally it's it's easier you don't need the heavyweightness of GET we just need to be able to that solve for merge conflicts and keep track of what's what on a timeline 
   One of the supportive services we want to provide in this environment to try to cast a wide net is our own Github Reponmaceip/MDMA Which is a Rust library currently that help with auto emerging conflicts We don't want our users to ever have to deal with emerge or you can think about that and so part of this work is to pull that repo down compile it to WAS and see how it could fit in this workflow we we may not even need to have it inside of an emulated risk process it could be compiled to Wazza i'm just running native in the browser Do some research on that and then lastly there's 
   Testing deployment 3rd party services integration and Webmcp is this last item You know things like Cloud Player domain names whatever and to that end we're also going to wire each of these up to be publicly addressable using maceip/freeholdSo as an example that means that a like Go echo server will have a public IP address in theory and a domain name and so users can from a different device test out the Go echo server just hit it and see it respond 

VERIFICATION:
 Items above and any future items added herein will be accompanied real tests and not mocked faked simulated implementations We do the hard work here we don't jump around it 
 
